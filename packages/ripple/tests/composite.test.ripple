import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount, flushSync, track, TrackedArray, effect } from 'ripple';

describe('composite components', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
		container = null;
	});

	it('renders composite components', () => {
		component Button({ count }) {
			<div>{count}</div>
		}

		component App() {
			let count = track(0);

			<button onClick={() => @count++}>{'Increment'}</button>
			<Button {@count} />
		}

		render(App);

		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container.querySelector('div').textContent).toBe('1');

		button.click();
		flushSync();

		expect(container.querySelector('div').textContent).toBe('2');
	});

	it('renders composite components with object state', () => {
		component Button({ obj }) {
			<button class='count2' onClick={() => {
				obj.@count++;
			}}>{obj.@count}</button>
		}

		component App() {
			<div>
				let obj = {
					count: track(0)
				};

				<span class='count'>{obj.@count}</span>
				<Button obj={obj} />
			</div>
		}

		render(App);

		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container.querySelector('.count').textContent).toBe('1');
		expect(container.querySelector('.count2').textContent).toBe('1');
	});

	it('renders composite components with object state wrapped in an if statement', () => {
		component Button({ obj }) {
			<button class='count2' onClick={() => {
				obj.@count++;
			}}>{obj.@count}</button>
		}

		component OtherComponent({ obj }) {
			<div class='count3'>{obj.@count}</div>
		}

		component App() {
			<div>
				let obj = {
					count: track(0)
				};

				<span class='count'>{obj.@count}</span>
				<span>{' '}</span>
				if (obj) {
					<Button obj={obj} />
				}

				if (obj) {
					<OtherComponent obj={obj} />
				}
			</div>
		}

		render(App);

		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container.querySelector('.count').textContent).toBe('1');
		expect(container.querySelector('.count2').textContent).toBe('1');
		expect(container.querySelector('.count3').textContent).toBe('1');
	});

	it('parents and children have isolated state', () => {
		component Button(props) {
			let count = track(() => props.count);
			<button onClick={() => { @count++; } }>{"child: " + @count}</button>
		}

		component App() {
			<div>
				let count = track(0);

				<button onClick={() => { @count++; } }>{"parent: " + @count}</button>
				<Button {@count} />
			</div>
		}

		render(App);

		const buttons = container.querySelectorAll('button');

		expect(buttons[0].textContent).toBe('parent: 0');
		expect(buttons[1].textContent).toBe('child: 0');

		buttons[0].click();
		flushSync();

		expect(buttons[0].textContent).toBe('parent: 1');
		expect(buttons[1].textContent).toBe('child: 1');

		buttons[1].click();
		flushSync();

		expect(buttons[0].textContent).toBe('parent: 1');
		expect(buttons[1].textContent).toBe('child: 2');
	});

	it('parents and children have isolated connected state (destructured props)', () => {
		component Button({count}) {
			let local_count = track(() => count);
			<button onClick={() => { @local_count++; } }>{"child: " + @local_count}</button>
		}

		component App() {
			<div>
				let count = track(0);

				<button onClick={() => { @count++; } }>{"parent: " + @count}</button>
				<Button {@count} />
			</div>
		}

		render(App);

		const buttons = container.querySelectorAll('button');

		expect(buttons[0].textContent).toBe('parent: 0');
		expect(buttons[1].textContent).toBe('child: 0');

		buttons[0].click();
		flushSync();

		expect(buttons[0].textContent).toBe('parent: 1');
		expect(buttons[1].textContent).toBe('child: 1');

		buttons[1].click();
		flushSync();

		expect(buttons[0].textContent).toBe('parent: 1');
		expect(buttons[1].textContent).toBe('child: 2');
	});

	it('correct handles passing through component props and children', () => {
		component Button({ A, B, children }) {
			<div>
				<A />
				<children />
				<B />
			</div>
		}

		component App() {
			<Button>
				component A() {
					<div>{"I am A"}</div>
				}
				<div>{"other text"}</div>
				component B() {
					<div>{"I am B"}</div>
				}
			</Button>
		}

		render(App);

		expect(container).toMatchSnapshot();
	});

	it('correctly handles default prop values', () => {
		component Child({ foo = 456 }) {
			<div>{foo}</div>
		}

		component App(props) {
			let foo = track(123);

			<Child />
			<Child {@foo} />
		}

		render(App);

		expect(container.querySelectorAll('div')[0].textContent).toBe('456');
		expect(container.querySelectorAll('div')[1].textContent).toBe('123');
	});

	it('correctly handles default prop values #2', () => {
		component Child({ foo = 456 }) {
			<div>{foo}</div>
		}

		component App(props) {
			let foo = 123;

			<Child />
			<Child {foo} />
		}

		render(App);

		expect(container.querySelectorAll('div')[0].textContent).toBe('456');
		expect(container.querySelectorAll('div')[1].textContent).toBe('123');
	});

	it('correctly handles no props', () => {
		component Child(props) {
			<div>{props.@foo}</div>
		}

		component App(props) {
			let foo = track(123);

			<Child />
			<Child {foo} />
		}

		render(App);

		expect(container.querySelectorAll('div')[0].textContent).toBe('');
		expect(container.querySelectorAll('div')[1].textContent).toBe('123');
	});

	it('correctly handles no props #2', () => {
		component Child({ foo }) {
			<div>{foo}</div>
		}

		component App(props) {
			let foo = track(123);

			<Child />
			<Child {@foo} />
		}

		render(App);

		expect(container.querySelectorAll('div')[0].textContent).toBe('');
		expect(container.querySelectorAll('div')[1].textContent).toBe('123');
	});

	it('handlers generic', () => {
		component ArrayTest() {
			let items = new TrackedArray<number>();
			items.push.apply(items, [1, 2, 3, 4, 5]);

			<pre>{items ? JSON.stringify(items) : 'Loading...'}</pre>
		}

		render(ArrayTest);
	});

	it('handles spreading of props', () => {
		let logs = [];

		component App() {
			const a = track(1);
			const b = track(2);
			const c = track(3);

			const obj = track(() => ({
				@a,
				@b,
				@c,
			}));

			<Child {...@obj} />

			<button onClick={() => { @a++; @b++; @c++; }}>{"Increment all"}</button>
		}

		component Child({ a, b, c }) {
			effect(() => {
				logs.push(`Child effect: ${a}, ${b}, ${c}`);
			});

			<div>{a + ' ' +  b + ' ' + c}</div>
		}

		render(App);
		flushSync();

		expect(container.querySelector('div').textContent).toBe('1 2 3');
		expect(logs).toEqual(['Child effect: 1, 2, 3']);

		const button = container.querySelector('button');
		button.click();
		flushSync();

		expect(container.querySelector('div').textContent).toBe('2 3 4');
		expect(logs).toEqual(['Child effect: 1, 2, 3', 'Child effect: 2, 3, 4']);
	});
});
