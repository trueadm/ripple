import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount } from 'ripple';

describe('generic patterns', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
		container = null;
	});

	it('tests simple generic function', () => {
		component App() {
			const e = new Map<string, Promise<number>>();
			const a = new Array<number>();

			const b = new Array<
				string
			>();

			<div class="still-works">
				<span>{'Test'}</span>
			</div>

			const someSource = new Array<number>(1, 2, 3);
			const d = someSource.map<number>((x) => x * 2).filter<boolean>((x) => !!x);
		}

		render(App);
	});

	it('tests member expression)', () => {
		component App() {
			class List<T> {
				items: T[];
				constructor() {
					this.items = [];
				}
			}

			<div class="still-works">
				<span>{'Test'}</span>
			</div>

			class Containers {
				static List<T>() {
					return new List<T>();
				}
			}

			const c = Containers.List<string>();
		}

		render(App);
	});

	/**
	 * Complex generics tests
	 * These currently break the parser
	 * We can't just use skip and then the tests are still parsed and compiled
	 */
	/*
		describe('complex generics', () => {
			it('tests after a call expression result', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>(): { build<V>(): V; data: T; key: U } {
								return {
									build<V>(): V {
										return 42 as V;
									},
									data: undefined as T,
									key: undefined as U
								};
							}
						});
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;

					const f = getBuilder()<ResultType>().build<number>();
				}
			});
		});
 	*/
});
