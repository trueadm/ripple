import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount } from 'ripple';

describe('generic patterns', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
		container = null;
	});

	it('tests simple generic function', () => {
		component App() {
			const e = new Map<string, Promise<number>>();
			const a = new Array<number>();

			const b = new Array<
				string
			>();

			<div class="still-works">
				<span>{'Test'}</span>
			</div>

			const someSource = new Array<number>(1, 2, 3);
			const d = someSource.map<number>((x) => x * 2).filter<boolean>((x) => !!x);
		}

		render(App);
	});

	it('tests member expression)', () => {
		component App() {
			class List<T> {
				items: T[];
				constructor() {
					this.items = [];
				}
			}

			<div class="still-works">
				<span>{'Test'}</span>
			</div>

			class Containers {
				static List<T>() {
					return new List<T>();
				}
			}

			const c = Containers.List<string>();
		}

		render(App);
	});

	/**
	 * Complex generics tests
	 * These currently break the parser
	 * We can't just use skip and then the tests are still parsed and compiled
	 *
	 * This test case involves object literal methods with generic type parameters
	 * and explicit return type annotations, which is not supported by TypeScript's
	 * parser when JSX mode is enabled. Even in pure TypeScript with JSX, this syntax
	 * requires trailing commas (e.g., <T,>) to disambiguate from JSX.
	 *
	 * For now, this test is commented out to allow the simple generic tests to run.
	 */
	
		describe('complex generics', () => {
			it ('tests simple generic function with return type', () => {
				component App() {
					function getBuilder() {
						return {
							build: function<T>() { return 'test' }
						}
					}
				}

				render(App);
			})

			it ('tests simple generic function with return type and no arrow function', () => {
				component App() {
					function getBuilder() {
						return {
							build<T>() { return 'test' }
						}
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					const f = getBuilder().build<string>();
				}

				render(App);
			})

			it ('tests simple generic arrow function with return type', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>() { return 'test' }
						})
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;
					const f = getBuilder()<ResultType>().build<string>();
					<div>{f}</div>
				}

				render(App);
			})

			it ('tests simple generic arrow function with explicit return type', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>(): U { return 'test' }
						})
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;
					const f = getBuilder()<ResultType>().build<string>();
					<div>{f}</div>
				}

				render(App);
			})

			it ('tests complex generic arrow function with return type', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>(): { build: <V>() => V; data: T; key: U } {
								return 'test';
							}
						})
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;
					const f = getBuilder()<ResultType>().build<string>();
					<div>{f}</div>
				}

				render(App);
			})

			it ('tests more complex generic arrow function with return type', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>(): { build: <V>() => V; data: T; key: U } {
								return {
									build<V>(): V {
										return 'test' as V;
									}
								};
							}
						});
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;
					const f = getBuilder()<ResultType>().build<string>();
					<div>{f}</div>
				}

				render(App);
			})

			it ('tests complex generic arrow function with return type', () => {
				component App() {
					function getBuilder() {
						return <T>() => ({
							build<U>(): { build: <V>() => V; data: T; key: U } {
								return {
									build<V>(): V {
										return 42 as V;
									},
									data: undefined as T,
									key: undefined as U
								};
							}
						});
					}

					<div class="still-works">
						<span>{'Test'}</span>
					</div>

					type ResultType = string;
					const f = getBuilder()<ResultType>().build<string>();
					<div>{f}</div>
				}

				render(App);
			})
		});

});
