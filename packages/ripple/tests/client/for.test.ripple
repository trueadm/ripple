import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount, flushSync, TrackedArray, track } from 'ripple';

describe('for statements', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
		container = null;
	});

	it('render a simple static array', () => {
		component App() {
			const items = ['Item 1', 'Item 2', 'Item 3'];

			for (const item of items) {
				<div class={item}>{item}</div>
			}
		}

		render(App);

		expect(container).toMatchSnapshot();
	});

	it('render a simple dynamic array', () => {
		component App() {
			const items = new TrackedArray('Item 1', 'Item 2', 'Item 3');

			for (const item of items) {
				<div class={item}>{item}</div>
			}

			<button onClick={() => items.push(`Item ${items.length + 1}`)}>{'Add Item'}</button>
		}

		render(App);
		expect(container).toMatchSnapshot();

		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container).toMatchSnapshot();
	});

	it('correctly handles intermediate statements in for block', () => {
		component App() {
			const items = new TrackedArray(1, 2, 3);

			<div>
				for (const item of items) {
					<div>
						<div>{item}</div>
						const some_text = item;
						<div>{some_text}</div>
					</div>
				}
			</div>

			<button onClick={() => items.push(items.length + 1)}>{"Add Item"}</button>
		}

		render(App);

		expect(container).toMatchSnapshot();
		
		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container).toMatchSnapshot();
	});

	it('correctly handles the index in a for...of loop', () => {
		component App() {
			const items = new TrackedArray('a', 'b', 'c');

			<div>
				for (let item of items; index i) {
					<div>{i + ' : ' + item}</div>
				}
			</div>

			<button onClick={() => items.push(String.fromCharCode(97 + items.length))}>{'Add Item'}</button>
			<button onClick={() => items.reverse()}>{'Reverse'}</button>
		}

		render(App);

		expect(container).toMatchSnapshot();

		const [button, button2] = container.querySelectorAll('button');

		button.click();
		flushSync();

		expect(container).toMatchSnapshot();

		button2.click();
		flushSync();

		expect(container).toMatchSnapshot();
	});

	it('correctly handles keyed for...of loops', () => {
		component App() {
			let items = track([
				{ id: 1, text: 'Item 1' },
				{ id: 2, text: 'Item 2' },
				{ id: 3, text: 'Item 3' },
			]);

			for (let item of @items; index i; key item.id) {
				<div>{i + ':' + item.text}</div>
			}

			<button onClick={() => {
				@items = @items.toReversed();
			}}>{'Reverse'}</button>
		}

		render(App);

		expect(container).toMatchSnapshot();

		const button = container.querySelector('button');

		button.click();
		flushSync();

		expect(container).toMatchSnapshot();
	});

	it('handles updating with new objects with same key', () => {
		component App() {
			let items = track([
				{ id: 1, text: 'Item 1' },
				{ id: 2, text: 'Item 2' },
				{ id: 3, text: 'Item 3' },
			]);

			for (let item of @items; index i; key item.id) {
				<div>{i + ':' + item.text}</div>
			}

			<button onClick={() => {
				@items[0].id = 3;
				@items[1].id = 2;
				@items[2].id = 1;

				@items = [
					{...@items[0], text: 'Item 1!'},
					{...@items[1], text: 'Item 2!'},
					{...@items[2], text: 'Item 3!'},
				];
			}}>{"Reverse"}</button>
		}

		render(App);
		expect(container).toMatchSnapshot();

		const button = container.querySelector('button');
		button.click();
		flushSync();

		expect(container).toMatchSnapshot();
	})
});
