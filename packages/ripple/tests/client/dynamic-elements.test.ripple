import { flushSync, track, createRefKey, trackSplit } from 'ripple';

describe('dynamic DOM elements', () => {

	it('renders static dynamic element', () => {
		component App() {
			let tag = track('div');

			<@tag>{'Hello World'}</@tag>
		}
		render(App);

		const element = container.querySelector('div');
		expect(element).toBeTruthy();
		expect(element.textContent).toBe('Hello World');
	});

	it('renders reactive dynamic element', () => {
		component App() {
			let tag = track('div');

			<button onClick={() => {
					@tag = 'span';
				}}>{'Change Tag'}</button>
			<@tag id="dynamic">{'Hello World'}</@tag>
		}
		render(App);
		
		// Initially should be a div
		let dynamicElement = container.querySelector('#dynamic');
		expect(dynamicElement.tagName).toBe('DIV');
		expect(dynamicElement.textContent).toBe('Hello World');
		
		// Click button to change tag
		const button = container.querySelector('button');
		button.click();
		flushSync();
		
		// Should now be a span
		dynamicElement = container.querySelector('#dynamic');
		expect(dynamicElement.tagName).toBe('SPAN');
		expect(dynamicElement.textContent).toBe('Hello World');
	});

	it('renders self-closing dynamic element', () => {
		component App() {
			let tag = track('input');

			<@tag type="text" value="test" />
		}
		render(App);

		const element = container.querySelector('input');
		expect(element).toBeTruthy();
		expect(element.type).toBe('text');
		expect(element.value).toBe('test');
	});

	it('handles dynamic element with attributes', () => {
		component App() {
			let tag = track('div');
			let className = track('test-class');

			<@tag class={@className} id="test" data-testid="dynamic-element">{'Content'}</@tag>
		}
		render(App);

		const element = container.querySelector('#test');
		expect(element.tagName).toBe('DIV');
		expect(element.className).toBe('test-class');
		expect(element.getAttribute('data-testid')).toBe('dynamic-element');
		expect(element.textContent).toBe('Content');
	});

	it('handles nested dynamic elements', () => {
		component App() {
			let outerTag = track('div');
			let innerTag = track('span');

			<@outerTag class="outer">
				<@innerTag class="inner">{'Nested content'}</@innerTag>
			</@outerTag>
		}
		render(App);

		const outer = container.querySelector('.outer');
		const inner = container.querySelector('.inner');

		expect(outer.tagName).toBe('DIV');
		expect(inner.tagName).toBe('SPAN');
		expect(inner.textContent).toBe('Nested content');
		expect(outer.contains(inner)).toBe(true);
	});

	it('handles dynamic element with class object', () => {
		component App() {
			let tag = track('div');
			let active = track(true);

			<@tag class={{ active: @active, 'dynamic-element': true }}>
				{'Element with class object'}
			</@tag>
		}
		render(App);

		const element = container.querySelector('div');
		expect(element).toBeTruthy();
		expect(element.classList.contains('active')).toBe(true);
		expect(element.classList.contains('dynamic-element')).toBe(true);
	});

	it('handles dynamic element with style object', () => {
		component App() {
			let tag = track('span');

			<@tag style={{ 
				color: 'red', 
				fontSize: '16px',
				fontWeight: 'bold'
			}}>
				{'Styled dynamic element'}
			</@tag>
		}
		render(App);

		const element = container.querySelector('span');
		expect(element).toBeTruthy();
		expect(element.style.color).toBe('red');
		expect(element.style.fontSize).toBe('16px');
		expect(element.style.fontWeight).toBe('bold');
	});

	it('handles dynamic element with spread attributes', () => {
		component App() {
			let tag = track('section');
			const attrs = {
				id: 'spread-section',
				'data-testid': 'spread-test',
				class: 'spread-class',
			};

			<@tag {...attrs} data-extra="additional">
				{'Element with spread attributes'}
			</@tag>
		}
		render(App);

		const element = container.querySelector('section');
		expect(element).toBeTruthy();
		expect(element.id).toBe('spread-section');
		expect(element.getAttribute('data-testid')).toBe('spread-test');
		expect(element.className).toBe('spread-class');
		expect(element.getAttribute('data-extra')).toBe('additional');
	});

	it('handles dynamic element with ref', () => {
		let capturedElement = null;

		component App() {
			let tag = track('article');

			<@tag {ref (node) => { capturedElement = node; }} id="ref-test">
				{'Element with ref'}
			</@tag>
		}
		render(App);
		flushSync();
		
		expect(capturedElement).toBeTruthy();
		expect(capturedElement.tagName).toBe('ARTICLE');
		expect(capturedElement.id).toBe('ref-test');
		expect(capturedElement.textContent).toBe('Element with ref');
	});

	it('handles dynamic element with createRefKey in spread', () => {
		component App() {
			let tag = track('header');

			function elementRef(node) {
				// Set an attribute on the element to prove ref was called
				node.setAttribute('data-spread-ref-called', 'true');
				node.setAttribute('data-spread-ref-tag', node.tagName.toLowerCase());
			}

			const dynamicProps = {
				id: 'spread-ref-test',
				class: 'ref-element',
				[createRefKey()]: elementRef
			};

			<@tag {...dynamicProps}>{'Element with spread ref'}</@tag>
		}
		render(App);
		flushSync();

		// Check that the spread ref was called by verifying attributes were set
		const element = container.querySelector('header');
		expect(element).toBeTruthy();
		expect(element.getAttribute('data-spread-ref-called')).toBe('true');
		expect(element.getAttribute('data-spread-ref-tag')).toBe('header');
		expect(element.id).toBe('spread-ref-test');
		expect(element.className).toBe('ref-element');
	});

	it('has reactive attributes on dynamic elements', () => {
		component App() {
			let tag = track('div');
			let count = track(0);
			
			<button onClick={() => { @count++; }}>{'Increment'}</button>
			<@tag 
				id={@count % 2 ? 'even' : 'odd'}
				class={@count % 2 ? 'even-class' : 'odd-class'}
				data-count={@count}
			>
				{'Count: '}{@count}
			</@tag>
		}

		render(App);
		
		const button = container.querySelector('button');
		const element = container.querySelector('div');
		
		// Initial state
		expect(element.id).toBe('odd');
		expect(element.className).toBe('odd-class');
		expect(element.getAttribute('data-count')).toBe('0');
		expect(element.textContent).toBe('Count: 0');
		
		// Click to increment
		button.click();
		flushSync();
		
		// Attributes should be reactive and update
		expect(element.id).toBe('even');
		expect(element.className).toBe('even-class');
		expect(element.getAttribute('data-count')).toBe('1');
		expect(element.textContent).toBe('Count: 1');
		
		// Click again
		button.click();
		flushSync();
		
		// Should toggle back
		expect(element.id).toBe('odd');
		expect(element.className).toBe('odd-class');
		expect(element.getAttribute('data-count')).toBe('2');
		expect(element.textContent).toBe('Count: 2');
	});

	it('applies scoped CSS to dynamic elements', () => {
		component App() {
			let tag = track('div');
			
			<@tag class="test-class">{'Dynamic element'}</@tag>
			
			<style>
				.test-class {
					color: red;
				}
			</style>
		}

		render(App);
		
		const element = container.querySelector('div');
		expect(element).toBeTruthy();
		console.log(element);
		expect(element.classList.contains('test-class')).toBe(true);
		
		// Check if scoped CSS class is present - THIS MIGHT FAIL if CSS pruning issue exists
		const classes = Array.from(element.classList);
		const hasScopedClass = classes.some(cls => cls.startsWith('ripple-'));
		expect(hasScopedClass).toBe(true);
	});

	it('applies scoped CSS to dynamic elements with reactive classes', () => {
		component App() {
			let tag = track('button');
			let count = track(0);
			
			<@tag 
				class={@count % 2 ? 'even' : 'odd'}
				id={@count % 2 ? 'even' : 'odd'}
				onClick={() => { @count++; }}
			>
				{'Count: '}{@count}
			</@tag>
			
			<style>
				.even {
					background-color: green;
					color: white;
				}
				.odd {
					background-color: red;
					color: white;
				}
			</style>
		}

		render(App);
		
		const button = container.querySelector('button');
		expect(button).toBeTruthy();
		
		// Initial state: should be odd (count=0, 0%2=false)
		expect(button.classList.contains('odd')).toBe(true);
		expect(button.classList.contains('even')).toBe(false);
		expect(button.id).toBe('odd');
		expect(button.textContent).toBe('Count: 0');
		
		// Check if scoped CSS hash is applied to dynamic element
		const classes = Array.from(button.classList);
		const hasScopedClass = classes.some(cls => cls.startsWith('ripple-'));
		expect(hasScopedClass).toBe(true);
		
		// Click to increment
		button.click();
		flushSync();
		
		// Should now be even (count=1, 1%2=true)  
		expect(button.classList.contains('even')).toBe(true);
		expect(button.classList.contains('odd')).toBe(false);
		expect(button.id).toBe('even');
		expect(button.textContent).toBe('Count: 1');
		
		// Scoped CSS class should still be present
		const newClasses = Array.from(button.classList);
		const stillHasScopedClass = newClasses.some(cls => cls.startsWith('ripple-'));
		expect(stillHasScopedClass).toBe(true);
		
		// Click again
		button.click();
		flushSync();
		
		// Should toggle back to odd (count=2, 2%2=false)
		expect(button.classList.contains('odd')).toBe(true);
		expect(button.classList.contains('even')).toBe(false);
		expect(button.id).toBe('odd');
		expect(button.textContent).toBe('Count: 2');
	});

	it('handles spread attributes with class and CSS scoping ', () => {
		component DyanamicButton(props) {
			const tag = track('button');
			const [children, rest] = trackSplit(props, ['children']);
			<@tag {...@rest}>{@rest.class}</@tag>
			
			<style>
				.even {
					background-color: green;
				}
				.odd {
					background-color: red;
				}
			</style>
		}

		component App() {
			const count = track(0);
			<DyanamicButton
				class={@count % 2 ? 'even' : 'odd'}
				id={@count % 2 ? 'even' : 'odd'}
				onClick={() => { @count++; }}
			/>
		}

		render(App);
		
		const button = container.querySelector('button');
		expect(button).toBeTruthy();
		
		
		// Initial state: should be odd (count=0, 0%2=false)
		expect(button.classList.contains('odd')).toBe(true);
		expect(button.classList.contains('even')).toBe(false);
		expect(button.id).toBe('odd');
		
		// Check if scoped CSS hash is applied (this is the critical test)
		const classes = Array.from(button.classList);
		const hasScopedClass = classes.some(cls => cls.startsWith('ripple-'));
		expect(hasScopedClass).toBe(true);
		
		// Click to increment
		button.click();
		flushSync();
		
		// Should now be even (count=1, 1%2=true)  
		expect(button.classList.contains('even')).toBe(true);
		expect(button.classList.contains('odd')).toBe(false);
		expect(button.id).toBe('even');
		
		// Both classes should still be present
		const newClasses = Array.from(button.classList);
		const stillHasScopedClass = newClasses.some(cls => cls.startsWith('ripple-'));
		expect(stillHasScopedClass).toBe(true);
		expect(newClasses.includes('even')).toBe(true);
	});
});