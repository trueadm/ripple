import { parse, compile, compile_to_volar_mappings } from 'ripple/compiler';

function count_occurrences(string, subString) {
	let count = 0;
	let pos = string.indexOf(subString);

	while (pos !== -1) {
		count++;
		pos = string.indexOf(subString, pos + subString.length);
	}

	return count;
}

describe('compiler > basics', () => {
	it('parses style content correctly', () => {
		const source = `export component App() {
  <div id="myid" class="myclass">{"Hello World"}</div>

  <style>#style</style>
}`;
		const style1 = '.myid {color: green }';
		const style2 = '#myid {color: green }';
		const style3 = 'div {color: green }';

		let input = source.replace('#style', style1);
		let ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style1);

		input = source.replace('#style', style2);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style2);

		input = source.replace('#style', style3);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style3);
	});

  it('renders without crashing', () => {
		component App() {
			let foo;
			let bar;
			let baz;

			foo = {};
			foo = {'test': 0};
			foo['abc'] = 123;

			bar = { 'def': 456 };

			baz = { 'ghi': 789 };
			baz['jkl'] = 987;
		}

		render(App);
	});

	it('renders without crashing using < character', () => {
	component App() {
		function bar() {
			for (let i = 0; i < 10; i++) {
				// do nothing
			}
			const x = 1 < 1;
		}

		let x = 5 < 10

		<div>{x}</div>
	}

		render(App);
	});

	it('renders lexical blocks without crashing', () => {
		component App() {
			<div>
				const a = 1;
				<div>
					const b = 1;
				</div>
				<div>
					const b = 1;
				</div>
			</div>
			<div>
				const a = 2;
				<div>
					const b = 1;
				</div>
			</div>
		}

		render(App);
	});

	it('renders without crashing using mapped types', () => {
		component App() {
			type RecordKey = 'test';
			type RecordValue = { a: string, b: number };

			const config: Record<RecordKey, RecordValue> = {
				test: {
					a: 'test',
					b: 1
				},
			};

			const config2: { [key in RecordKey]: RecordValue } = {
				test: {
					a: 'test2',
					b: 2
				}
			}

			const config3: { [key: RecordKey]: RecordValue } = {
				test: {
					a: 'test3',
					b: 3
				}
			}
		}

		render(App);
	});

	it('renders without crashing using object destructuring', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			<div>
				{'a '}{a} {'b '} {b} {'rest '} {JSON.stringify(rest)}

				<div>

				</div>
			</div>
		}

		render(App);
	});

	it('renders without crashing using object destructuring #2', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			{'a '}{a} {'b '} {b} {'rest '} {JSON.stringify(rest)}

			<div>

			</div>
		}

		render(App);
	});

	it('should not fail with random TS syntax', () => {
		function tagFn() {
			return null;
		}

		function Wrapper() {
			return {
				unwrap: function<T>() {
					return null as unknown as T;
				}
			}
		}

		component App() {
			let x: number[] = [] as number[];

			const n = new Wrapper<number>().unwrap<string>();

			const tagResult = tagFn`value`;

			interface Node<T> {
				value: T;
			}

			class Box<T> {
				value: T;

				method<T>(): T {
				return this.value;
				}
			}

			let flag = true;

			const s = flag ? new Box<number>() : new Box<string>();
		}

		render(App);
	});

	it('compiles without needing semicolons between statements and JSX', () => {
		const source = `export component App() {
	<div>const code4 = 4

	const code3 = 3
		<div>
			<div>
				const code = 1
			</div>
			const code2 = 2
		</div>
	</div>
}`;

		const result = compile(source, 'test.ripple', { mode: 'client' });
	});

	it("doesn't add duplicate imports when encountering shorthand syntax", () => {
		const source = `
import {
	TrackedArray,
	TrackedObject,
	TrackedSet,
	TrackedMap,
	createRefKey,
} from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = #Set([1, 2, 3]);
	const map = #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, "TrackedArray")).toBe(2);
		expect(count_occurrences(result, "TrackedObject")).toBe(2);
		expect(count_occurrences(result, "TrackedSet")).toBe(2);
		expect(count_occurrences(result, "TrackedMap")).toBe(2);
		expect(count_occurrences(result, "createRefKey")).toBe(2);
	});

	it("doesn't add duplicate imports for renamed imports when encountering shorthand syntax", () => {
		const source = `
import {
	TrackedArray as TA,
	TrackedObject as TO,
	TrackedSet as TS,
	TrackedMap as TM,
	createRefKey as crk,
} from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = #Set([1, 2, 3]);
	const map = #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, "TrackedArray")).toBe(1);
		expect(count_occurrences(result, "TA")).toBe(2);
		expect(count_occurrences(result, "TrackedObject")).toBe(1);
		expect(count_occurrences(result, "TO")).toBe(2);
		expect(count_occurrences(result, "TrackedSet")).toBe(1);
		expect(count_occurrences(result, "TS")).toBe(2);
		expect(count_occurrences(result, "TrackedMap")).toBe(1);
		expect(count_occurrences(result, "TM")).toBe(2);
		expect(count_occurrences(result, "createRefKey")).toBe(1);
		expect(count_occurrences(result, "crk")).toBe(2);
	});

	it('adds missing imports for shorthand syntax', () => {
		const source = `
component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = #Set([1, 2, 3]);
	const map = #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, "TrackedArray")).toBe(2);
		expect(count_occurrences(result, "TrackedObject")).toBe(2);
		expect(count_occurrences(result, "TrackedSet")).toBe(2);
		expect(count_occurrences(result, "TrackedMap")).toBe(2);
		expect(count_occurrences(result, "createRefKey")).toBe(2);
	});

	it('only adds missing imports for shorthand syntax, reusing existing ones', () => {
		const source = `
import { TrackedArray, TrackedMap, createRefKey as crk } from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = #Set([1, 2, 3]);
	const map = #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, "TrackedArray")).toBe(2);
		expect(count_occurrences(result, "TrackedObject")).toBe(2);
		expect(count_occurrences(result, "TrackedSet")).toBe(2);
		expect(count_occurrences(result, "TrackedMap")).toBe(2);
		expect(count_occurrences(result, "createRefKey")).toBe(1);
		expect(count_occurrences(result, "crk")).toBe(2);
	});
});
