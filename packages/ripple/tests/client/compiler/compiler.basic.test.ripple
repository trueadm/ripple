import { parse, compile, compile_to_volar_mappings } from 'ripple/compiler';

function count_occurrences(string, subString) {
	let count = 0;
	let pos = string.indexOf(subString);

	while (pos !== -1) {
		count++;
		pos = string.indexOf(subString, pos + subString.length);
	}

	return count;
}

describe('compiler > basics', () => {
	it('parses style content correctly', () => {
		const source = `export component App() {
  <div id="myid" class="myclass">{"Hello World"}</div>

  <style>#style</style>
}`;
		const style1 = '.myid {color: green }';
		const style2 = '#myid {color: green }';
		const style3 = 'div {color: green }';

		let input = source.replace('#style', style1);
		let ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style1);

		input = source.replace('#style', style2);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style2);

		input = source.replace('#style', style3);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style3);
	});

	it('renders without crashing', () => {
		component App() {
			let foo;
			let bar;
			let baz;

			foo = {};
			foo = { test: 0 };
			foo['abc'] = 123;

			bar = { def: 456 };

			baz = { ghi: 789 };
			baz['jkl'] = 987;
		}

		render(App);
	});

	it('renders without crashing using < character', () => {
		component App() {
			function bar() {
				for (let i = 0; i < 10; i++) {
					// do nothing
				}
				const x = 1 < 1;
			}

			let x = 5 < 10;

			<div>{x}</div>
		}

		render(App);
	});

	it('renders lexical blocks without crashing', () => {
		component App() {
			<div>
				const a = 1;
				<div>
					const b = 1;
				</div>
				<div>
					const b = 1;
				</div>
			</div>
			<div>
				const a = 2;
				<div>
					const b = 1;
				</div>
			</div>
		}

		render(App);
	});

	it('renders without crashing using mapped types', () => {
		component App() {
			type RecordKey = 'test';
			type RecordValue = { a: string; b: number };

			const config: Record<RecordKey, RecordValue> = {
				test: {
					a: 'test',
					b: 1,
				},
			};

			const config2: { [key in RecordKey]: RecordValue } = {
				test: {
					a: 'test2',
					b: 2,
				},
			};

			const config3: { [key: RecordKey]: RecordValue } = {
				test: {
					a: 'test3',
					b: 3,
				},
			};
		}

		render(App);
	});

	it('renders without crashing using object destructuring', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			<div>
				{'a '}
				{a}
				{'b '}
				{b}
				{'rest '}
				{JSON.stringify(rest)}

				<div />
			</div>
		}

		render(App);
	});

	it('renders without crashing using object destructuring #2', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			{'a '}
			{a}
			{'b '}
			{b}
			{'rest '}
			{JSON.stringify(rest)}

			<div />
		}

		render(App);
	});

	it('should not fail with random TS syntax', () => {
		function tagFn() {
			return null;
		}

		function Wrapper() {
			return {
				unwrap: function <T>() {
					return null as unknown as T;
				},
			};
		}

		component App() {
			let x: number[] = [] as number[];

			const n = new Wrapper<number>().unwrap<string>();

			const tagResult = tagFn`value`;

			interface Node<T> {
				value: T;
			}

			class Box<T> {
				value: T;

				method<T>(): T {
					return this.value;
				}
			}

			let flag = true;

			const s = flag ? new Box<number>() : new Box<string>();
		}

		render(App);
	});

	it('compiles without needing semicolons between statements and JSX', () => {
		const source = `export component App() {
	<div>const code4 = 4

	const code3 = 3
		<div>
			<div>
				const code = 1
			</div>
			const code2 = 2
		</div>
	</div>
}`;

		const result = compile(source, 'test.ripple', { mode: 'client' });
	});

	it('doesn\'t add duplicate imports when encountering shorthand syntax', () => {
		const source = `
import {
	TrackedArray,
	TrackedObject,
	TrackedSet,
	TrackedMap,
	createRefKey,
} from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = new #Set([1, 2, 3]);
	const map = new #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, 'TrackedArray')).toBe(2);
		expect(count_occurrences(result, 'TrackedObject')).toBe(2);
		expect(count_occurrences(result, 'TrackedSet')).toBe(2);
		expect(count_occurrences(result, 'TrackedMap')).toBe(2);
		expect(count_occurrences(result, 'createRefKey')).toBe(2);
	});

	it(
		'doesn\'t add duplicate imports for renamed imports when encountering shorthand syntax',
		() => {
			const source = `
import {
	TrackedArray as TA,
	TrackedObject as TO,
	TrackedSet as TS,
	TrackedMap as TM,
	createRefKey as crk,
} from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = new #Set([1, 2, 3]);
	const map = new #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
			const result = compile_to_volar_mappings(source, 'test.ripple').code;

			expect(count_occurrences(result, 'TrackedArray')).toBe(1);
			expect(count_occurrences(result, 'TA')).toBe(2);
			expect(count_occurrences(result, 'TrackedObject')).toBe(1);
			expect(count_occurrences(result, 'TO')).toBe(2);
			expect(count_occurrences(result, 'TrackedSet')).toBe(1);
			expect(count_occurrences(result, 'TS')).toBe(2);
			expect(count_occurrences(result, 'TrackedMap')).toBe(1);
			expect(count_occurrences(result, 'TM')).toBe(2);
			expect(count_occurrences(result, 'createRefKey')).toBe(1);
			expect(count_occurrences(result, 'crk')).toBe(2);
		},
	);

	it('adds missing imports for shorthand syntax', () => {
		const source = `
component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = new #Set([1, 2, 3]);
	const map = new #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, 'TrackedArray')).toBe(2);
		expect(count_occurrences(result, 'TrackedObject')).toBe(2);
		expect(count_occurrences(result, 'TrackedSet')).toBe(2);
		expect(count_occurrences(result, 'TrackedMap')).toBe(2);
		expect(count_occurrences(result, 'createRefKey')).toBe(2);
	});

	it('only adds missing imports for shorthand syntax, reusing existing ones', () => {
		const source = `
import { TrackedArray, TrackedMap, createRefKey as crk } from 'ripple';

component App() {
	const items = #[1, 2, 3];
	const obj = #{ a: 1, b: 2, c: 3 };
	const set = new #Set([1, 2, 3]);
	const map = new #Map([['a', 1], ['b', 2], ['c', 3]]);

	<div {ref () => {}} />
}
`;
		const result = compile_to_volar_mappings(source, 'test.ripple').code;

		expect(count_occurrences(result, 'TrackedArray')).toBe(2);
		expect(count_occurrences(result, 'TrackedObject')).toBe(2);
		expect(count_occurrences(result, 'TrackedSet')).toBe(2);
		expect(count_occurrences(result, 'TrackedMap')).toBe(2);
		expect(count_occurrences(result, 'createRefKey')).toBe(1);
		expect(count_occurrences(result, 'crk')).toBe(2);
	});

	it('should not error on having js below markup in the same scope', () => {
		const code = `
component Card(props) {
	<div class="card">
		<props.children />
	</div>
}

export component App() {
	<Card>
		component children() {
			<p>{'Card content here'}</p>
		}
	</Card>

	const test = 5;

	<div>{test}</div>
}
`;
		expect(() => compile(code, 'test.ripple')).not.toThrow();
	});

	it('should not error on `this` MemberExpression with a UpdateExpression', () => {
		const code = `
class Test {
	constructor() {
		this.count = 0;
		this.count++; // This should not fail
	}
}

export component App() {
	const test = new Test();
	<div>{test.count}</div>
}
`;
		expect(() => compile(code, 'test.ripple')).not.toThrow();
	});
});
