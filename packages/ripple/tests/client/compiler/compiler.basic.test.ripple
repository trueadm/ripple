import { parse, compile } from 'ripple/compiler';

describe('compiler > basics', () => {
	it('parses style content correctly', () => {
		const source = `export component App() {
  <div id="myid" class="myclass">{"Hello World"}</div>

  <style>#style</style>
}`;
		const style1 = '.myid {color: green }';
		const style2 = '#myid {color: green }';
		const style3 = 'div {color: green }';

		let input = source.replace('#style', style1);
		let ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style1);

		input = source.replace('#style', style2);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style2);

		input = source.replace('#style', style3);
		ast = parse(input);
		expect(ast.body[0].declaration.css.source).toEqual(style3);
	});

  it('renders without crashing', () => {
		component App() {
			let foo;
			let bar;
			let baz;

			foo = {};
			foo = {'test': 0};
			foo['abc'] = 123;

			bar = { 'def': 456 };

			baz = { 'ghi': 789 };
			baz['jkl'] = 987;
		}

		render(App);
	});

	it('renders without crashing using < character', () => {
	component App() {
		function bar() {
			for (let i = 0; i < 10; i++) {
				// do nothing
			}
			const x = 1 < 1;
		}

		let x = 5 < 10

		<div>{x}</div>
	}

		render(App);
	});

	it('renders lexical blocks without crashing', () => {
		component App() {
			<div>
				const a = 1;
				<div>
					const b = 1;
				</div>
				<div>
					const b = 1;
				</div>
			</div>
			<div>
				const a = 2;
				<div>
					const b = 1;
				</div>
			</div>
		}

		render(App);
	});

	it('renders without crashing using mapped types', () => {
		component App() {
			type RecordKey = 'test';
			type RecordValue = { a: string, b: number };

			const config: Record<RecordKey, RecordValue> = {
				test: {
					a: 'test',
					b: 1
				},
			};

			const config2: { [key in RecordKey]: RecordValue } = {
				test: {
					a: 'test2',
					b: 2
				}
			}

			const config3: { [key: RecordKey]: RecordValue } = {
				test: {
					a: 'test3',
					b: 3
				}
			}
		}

		render(App);
	});

	it('renders without crashing using object destructuring', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			<div>
				{'a '}{a} {'b '} {b} {'rest '} {JSON.stringify(rest)}

				<div>

				</div>
			</div>
		}

		render(App);
	});

	it('renders without crashing using object destructuring #2', () => {
		component App() {
			const obj = { a: 1, b: 2, c: 3 };
			const { a, b, ...rest } = obj;

			{'a '}{a} {'b '} {b} {'rest '} {JSON.stringify(rest)}

			<div>

			</div>
		}

		render(App);
	});

	it('should not fail with random TS syntax', () => {
		function tagFn() {
			return null;
		}

		function Wrapper() {
			return {
				unwrap: function<T>() {
					return null as unknown as T;
				}
			}
		}

		component App() {
			let x: number[] = [] as number[];

			const n = new Wrapper<number>().unwrap<string>();

			const tagResult = tagFn`value`;

			interface Node<T> {
				value: T;
			}

			class Box<T> {
				value: T;

				method<T>(): T {
				return this.value;
				}
			}

			let flag = true;

			const s = flag ? new Box<number>() : new Box<string>();
		}

		render(App);
	});

	it('compiles without needing semicolons between statements and JSX', () => {
		const source = `export component App() {
	<div>const code4 = 4

	const code3 = 3
		<div>
			<div>
				const code = 1
			</div>
			const code2 = 2
		</div>
	</div>
}`;

		const result = compile(source, 'test.ripple', { mode: 'client' });
	});
});
