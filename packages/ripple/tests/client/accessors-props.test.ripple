import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount, flushSync, effect, track } from 'ripple';

describe('prop accessors', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
		container = null;
	});

  it('should render a basic prop accessor on a composite component', () => {
    const logs = [];

    component Child(props) {
      effect(() => {
        logs.push('App effect', props.@foo);
      });

      <button onClick={() => props.@foo++}>{"Increment foo"}</button>
    }

    component App(props) {
      let foo = track(0);

      <Child {foo} />

      <div>{"parent foo: " + @foo}</div>

      <button onClick={() => { @foo++; }}>{"Increment parent foo"}</button>
    }

    render(App);
    flushSync();

    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 0');
    expect(logs).toEqual(['App effect', 0]);

    const [button, button2] = container.querySelectorAll('button');

    button.click();
    flushSync();
    
    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 1');
    expect(logs).toEqual(['App effect', 0, 'App effect', 1]);

    button2.click();
    flushSync();

    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 2');
    expect(logs).toEqual(['App effect', 0, 'App effect', 1, 'App effect', 2]);
  });

  // Note: Disabled this test for further investigation.
  it.skip('should render a basic prop accessor on a composite component #2', () => {
    const logs = [];

    component Child({ foo }) {
      effect(() => {
        logs.push('App effect', props.foo);
      });

      <button onClick={() => props.foo++}>{"Increment foo"}</button>
    }

    component App() {
      let foo = track(0);

      <Child foo:={() => {
          return @foo;
        }, v => {
          // do not update parent
        }} />

      <div>{"parent foo: " + @foo}</div>

      <button onClick={() => { foo++ }}>{"Increment parent foo"}</button>
    }

    render(App);
    flushSync();

    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 0');
    expect(logs).toEqual(['App effect', 0]);

    const [button, button2] = container.querySelectorAll('button');

    button.click();
    flushSync();
      
    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 0');
    expect(logs).toEqual(['App effect', 0]);

    button2.click();
    flushSync();

    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 1');
    expect(logs).toEqual(['App effect', 0, 'App effect', 1]);

    button2.click();
    flushSync();

    expect(container.querySelectorAll('div')[0].textContent).toBe('parent foo: 2');
    expect(logs).toEqual(['App effect', 0, 'App effect', 1, 'App effect', 2]);
  });

  it('handles a simple getter prop accessor with no setter', () =>{
    component Parent() {
      let value = track(123);

      <Child value:={() => @value} />

      <button onClick={() => { @value++ }}>{"Increment value"}</button>
    }

    component Child({ value }) {
      <div>{value}</div>
    }

    render(Parent);

    expect(container.querySelector('div').textContent).toBe('123');

    const button = container.querySelector('button');
    button.click();
    flushSync();

    expect(container.querySelector('div').textContent).toBe('124');

    button.click();
    flushSync();

    expect(container.querySelector('div').textContent).toBe('125');
  });
});