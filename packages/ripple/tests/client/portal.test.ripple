import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount, Portal, track, flushSync } from 'ripple';

describe('Portal', () => {
	let container;

	function render(component) {
		mount(component, {
			target: container,
		});
	}

	beforeEach(() => {
		container = document.createElement('div');
		document.body.appendChild(container);
	});

	afterEach(() => {
		document.body.removeChild(container);
	});

	it('renders portal content to target element', () => {
		const target = document.createElement('div');
		document.body.appendChild(target);

		component TestPortal() {
			<Portal target={target}><div class='portal-content'>{'Portal works!'}</div></Portal>
		}

		render(TestPortal);

		// Portal content should be in the target, not in container
		expect(container.querySelector('.portal-content')).toBeNull();
		expect(target.querySelector('.portal-content')).toBeTruthy();
		expect(target.querySelector('.portal-content').textContent).toBe('Portal works!');

		document.body.removeChild(target);
	});

	it('renders portal content to document.body', () => {
		component TestPortal() {
			<Portal target={document.body}><div class='body-portal'>{'In document.body!'}</div></Portal>
		}

		render(TestPortal);

		// Should not be in container
		expect(container.querySelector('.body-portal')).toBeNull();

		// Should be in document.body
		expect(document.body.querySelector('.body-portal')).toBeTruthy();
		expect(document.body.querySelector('.body-portal').textContent).toBe('In document.body!');
	});

	it('cleans up portal content when destroyed via conditional rendering', () => {
		component TestPortal() {
			let open = track(true);

			if (@open) {
				<Portal target={document.body}><div class='conditional-portal'>{'Conditional content'}</div></Portal>
			}

			<button onClick={() => @open = false}>{'Close'}</button>
		}

		render(TestPortal);

		// Initially portal content should be present
		expect(document.body.querySelector('.conditional-portal')).toBeTruthy();

		// Click close button to destroy portal
		container.querySelector('button').click();
		flushSync();

		// Portal content should be cleaned up
		expect(document.body.querySelector('.conditional-portal')).toBeNull();
	});

	it('opens and closes portal via conditional rendering', () => {
		component TestPortal() {
			let open = track(false);

			if (@open) {
				<Portal target={document.body}><div class='toggle-portal'>
					{'Content'}
					<button onClick={() => @open = false}>{'Close'}</button>
				</div></Portal>
			}

			if (!@open) {
				<button onClick={() => @open = true}>{'Open'}</button>
			}
		}

		render(TestPortal);

		// Open the portal
		container.querySelector('button').click();
		flushSync();
		expect(document.body.querySelector('.toggle-portal')).toBeTruthy();

		// Close the portal - this should work without errors
		expect(() => {
			document.body.querySelector('button').click();
			flushSync();
		}).not.toThrow();

		// Portal content should be cleaned up
		expect(document.body.querySelector('.toggle-portal')).toBeNull();
	});

	it.skip('updates portal content when target changes', () => {
		const target1 = document.createElement('div');
		const target2 = document.createElement('div');
		target1.id = 'target1';
		target2.id = 'target2';
		document.body.appendChild(target1);
		document.body.appendChild(target2);

		component TestPortal() {
			let useTarget2 = track(false);
			let currentTarget = @useTarget2 ? target2 : target1;

			<Portal target={currentTarget}><div class='moving-portal'>{'Moving content'}</div></Portal>

			<button onClick={() => @useTarget2 = !@useTarget2}>{'Switch Target'}</button>
		}

		render(TestPortal);

		// Initially in target1
		expect(target1.querySelector('.moving-portal')).toBeTruthy();
		expect(target2.querySelector('.moving-portal')).toBeNull();

		// Switch to target2
		container.querySelector('button').click();
		flushSync();

		// Give more time for cleanup and re-render
		expect(target2.querySelector('.moving-portal')).toBeTruthy();
		expect(target1.querySelector('.moving-portal')).toBeNull();

		document.body.removeChild(target1);
		document.body.removeChild(target2);
	});

	it('handles multiple portals simultaneously', () => {
		const target1 = document.createElement('div');
		const target2 = document.createElement('div');
		target1.id = 'multi-target1';
		target2.id = 'multi-target2';
		document.body.appendChild(target1);
		document.body.appendChild(target2);

		component TestMultiPortal() {
			<Portal target={target1}><div class='portal1'>{'Portal 1 content'}</div></Portal>

			<Portal target={target2}><div class='portal2'>{'Portal 2 content'}</div></Portal>
		}

		render(TestMultiPortal);

		// Both portals should render in their respective targets
		expect(target1.querySelector('.portal1')).toBeTruthy();
		expect(target1.querySelector('.portal1').textContent).toBe('Portal 1 content');

		expect(target2.querySelector('.portal2')).toBeTruthy();
		expect(target2.querySelector('.portal2').textContent).toBe('Portal 2 content');

		// Make sure they don't interfere with each other
		expect(target1.querySelector('.portal2')).toBeNull();
		expect(target2.querySelector('.portal1')).toBeNull();

		document.body.removeChild(target1);
		document.body.removeChild(target2);
	});

	it('handles portal with reactive content', () => {
		component TestReactivePortal() {
			let count = track(0);

			<Portal target={document.body}><div class='reactive-portal'>
				{'Count: '}
				{String(@count)}
				<button onClick={() => @count++}>{'Increment'}</button>
			</div></Portal>
		}

		render(TestReactivePortal);

		const portalElement = document.body.querySelector('.reactive-portal');
		expect(portalElement).toBeTruthy();
		expect(portalElement.textContent).toContain('Count: 0');

		// Click increment button
		portalElement.querySelector('button').click();
		flushSync();

		expect(portalElement.textContent).toContain('Count: 1');
	});

	// Cleanup any leftover portal content after each test
	afterEach(() => {
		// Remove any portal content that might be left in document.body
		const portals = document.body.querySelectorAll('.portal-content, .body-portal, .conditional-portal, .toggle-portal, .moving-portal, .portal1, .portal2, .reactive-portal');
		portals.forEach(el => el.remove());
	});
});