import { track, flushSync } from 'ripple';
import { act, createContext, useContext, Suspense } from 'react';
import { vi } from 'vitest';
import { Ripple } from '@ripple-ts/compat-react';
import { createRoot } from 'react-dom/client';
import { jsx, jsxs } from 'react/jsx-runtime';
import { RippleRoot } from '@ripple-ts/compat-react';

describe('compat-react', () => {
	describe('tsx:react integration', () => {
		it('should render basic React JSX inside tsx:react tags', async () => {
			component App() {
				<div>
					<h1>{'Hello from Ripple'}</h1>
					<tsx:react>
						<div className="react-content">Hello from React</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const rippleHeading = container.querySelector('h1');
			const reactDiv = container.querySelector('.react-content');
			expect(rippleHeading).toBeTruthy();
			expect(rippleHeading.textContent).toBe('Hello from Ripple');
			expect(reactDiv).toBeTruthy();
			expect(reactDiv.textContent).toBe('Hello from React');
		});

		it('should render React fragments inside tsx:react tags', async () => {
			component App() {
				<div>
					<tsx:react>
						<>
							<span className="first">First</span>
							<span className="second">Second</span>
						</>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const first = container.querySelector('.first');
			const second = container.querySelector('.second');
			expect(first).toBeTruthy();
			expect(first.textContent).toBe('First');
			expect(second).toBeTruthy();
			expect(second.textContent).toBe('Second');
		});

		it('should render nested React components', async () => {
			component App() {
				<div>
					<tsx:react>
						<div className="wrapper">
							<div className="inner">
								<span className="content">Nested content</span>
							</div>
						</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const wrapper = container.querySelector('.wrapper');
			const inner = container.querySelector('.inner');
			const content = container.querySelector('.content');
			expect(wrapper).toBeTruthy();
			expect(inner).toBeTruthy();
			expect(content).toBeTruthy();
			expect(content.textContent).toBe('Nested content');
		});

		it('should mix Ripple and React content', async () => {
			component App() {
				<div class="container">
					<div class="ripple">{'This is Ripple'}</div>
					<tsx:react>
						<div className="react">This is React</div>
					</tsx:react>
					<div class="ripple-2">{'Back to Ripple'}</div>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const rippleDiv = container.querySelector('.ripple');
			const reactDiv = container.querySelector('.react');
			const rippleDiv2 = container.querySelector('.ripple-2');
			expect(rippleDiv).toBeTruthy();
			expect(rippleDiv.textContent).toBe('This is Ripple');
			expect(reactDiv).toBeTruthy();
			expect(reactDiv.textContent).toBe('This is React');
			expect(rippleDiv2).toBeTruthy();
			expect(rippleDiv2.textContent).toBe('Back to Ripple');
		});

		it('should handle multiple tsx:react blocks', async () => {
			component App() {
				<div>
					<tsx:react>
						<div className="react-1">React Block 1</div>
					</tsx:react>
					<div class="ripple-middle">{'Ripple in between'}</div>
					<tsx:react>
						<div className="react-2">React Block 2</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const react1 = container.querySelector('.react-1');
			const middle = container.querySelector('.ripple-middle');
			const react2 = container.querySelector('.react-2');
			expect(react1).toBeTruthy();
			expect(react1.textContent).toBe('React Block 1');
			expect(middle).toBeTruthy();
			expect(middle.textContent).toBe('Ripple in between');
			expect(react2).toBeTruthy();
			expect(react2.textContent).toBe('React Block 2');
		});

		it('should handle React components with attributes', async () => {
			component App() {
				<div>
					<tsx:react>
						<div className="react" id="test-id">
							<span>Content</span>
						</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const reactDiv = container.querySelector('.react');
			expect(reactDiv).toBeTruthy();
			expect(reactDiv.id).toBe('test-id');
			expect(reactDiv.querySelector('span').textContent).toBe('Content');
		});

		it('should handle nested fragments', async () => {
			component App() {
				<div>
					<tsx:react>
						<>
							<div className="outer">Outer</div>
							<>
								<div className="inner">Inner</div>
							</>
						</>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const outer = container.querySelector('.outer');
			const inner = container.querySelector('.inner');
			expect(outer).toBeTruthy();
			expect(outer.textContent).toBe('Outer');
			expect(inner).toBeTruthy();
			expect(inner.textContent).toBe('Inner');
		});

		it('should handle complex nested structures', async () => {
			component App() {
				<div>
					<tsx:react>
						<div className="list">
							<ul>
								<li>Item 1</li>
								<li>Item 2</li>
								<li>Item 3</li>
							</ul>
						</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const list = container.querySelector('.list');
			const items = container.querySelectorAll('li');
			expect(list).toBeTruthy();
			expect(items.length).toBe(3);
			expect(items[0].textContent).toBe('Item 1');
			expect(items[1].textContent).toBe('Item 2');
			expect(items[2].textContent).toBe('Item 3');
		});

		it('should handle empty fragments', async () => {
			component App() {
				<div>
					<tsx:react>
						<></>
					</tsx:react>
					<div class="after">{'After empty fragment'}</div>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const after = container.querySelector('.after');
			expect(after).toBeTruthy();
			expect(after.textContent).toBe('After empty fragment');
		});

		it('should work with Ripple reactivity', async () => {
			component App() {
				let count = track(0);
				<div>
					<div class="ripple-count">{@count}</div>
					<button onClick={() => @count++}>{'Increment'}</button>
					<tsx:react>
						<div className="react-message">
							{'React content is static'}
						</div>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const rippleCount = container.querySelector('.ripple-count');
			const button = container.querySelector('button');
			const reactMessage = container.querySelector('.react-message');
			expect(rippleCount.textContent).toBe('0');
			expect(reactMessage.textContent).toBe('React content is static');
			button.click();
			flushSync();
			expect(rippleCount.textContent).toBe('1');
			expect(reactMessage.textContent).toBe('React content is static');
			button.click();
			flushSync();
			expect(rippleCount.textContent).toBe('2');
		});

		it('should handle a call expression at the top-level of a tsx:react block', async () => {
			function renderReactText() {
				return 'This is rendered from a React component!';
			}

			component App() {
				<div>
					<tsx:react>
						{renderReactText()}
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const reactContent = container.querySelector('div > div');
			expect(reactContent).toBeTruthy();
			expect(reactContent.textContent).toBe('This is rendered from a React component!');
		});

		it('should handle a React context propagation', async () => {
			const SomeContext = createContext('Default Value');

			function ReactChild() {
				return useContext(SomeContext);
			}

			component App() {
				<div>
					<tsx:react>
						<SomeContext.Provider value="Provided Value">
							<ReactChild />
						</SomeContext.Provider>
					</tsx:react>
				</div>
			}

			await act(async () => {
				render(App);
			});

			const reactContent = container.querySelector('div > div');
			expect(reactContent).toBeTruthy();
			expect(reactContent.textContent).toBe('Provided Value');
		});

		it('should handle React errors', async () => {
			function ReactChild() {
				throw new Error('Test Error');
			}

			component App() {
				try {
					<div>
						<tsx:react>
							<ReactChild />
						</tsx:react>
					</div>
				} catch (e) {
					<div class="error">{'ReactChiild had an error'}</div>
				}
			}

			await act(async () => {
				render(App);
			});

			const reactContent = container.querySelector('div > div');
			expect(reactContent).toBeTruthy();
			expect(reactContent.textContent).toBe('ReactChiild had an error');
		});

		it('should handle React errors #2', async () => {
			function ReactChild() {
				throw new Error('Test Error');
			}

			component RippleChild() {
				<tsx:react>
					<ReactChild />
				</tsx:react>
			}

			component App() {
				try {
					<div>
						<tsx:react>
							<Ripple component={RippleChild} />
						</tsx:react>
					</div>
				} catch (e) {
					<div class="error">{'ReactChiild had an error'}</div>
				}
			}

			await act(async () => {
				render(App);
			});

			const reactContent = container.querySelector('div > div');
			expect(reactContent).toBeTruthy();
			expect(reactContent.textContent).toBe('ReactChiild had an error');
		});

		it('Should handle React context', async () => {
			const DemoContext = createContext(null);

			function DeepReactChild() {
				const contextValue = useContext(DemoContext);
				return jsx('div', { children: `Deep child, context value is: ${contextValue}` });
			}

			component RippleChild() {
				<tsx:react>
					<DeepReactChild />
				</tsx:react>
			}

			function ReactChild() {
				return jsx(Ripple, {
					component: RippleChild,
				});
			}

			component App() {
				<tsx:react>
					<DemoContext.Provider value={'Hello from Context!'}>
						<ReactChild />
					</DemoContext.Provider>
				</tsx:react>
			}

			await act(async () => {
				render(App);
			});

			const deepChild = container.querySelector('div');
			expect(deepChild).toBeTruthy();
			expect(deepChild.textContent).toBe('Deep child, context value is: Hello from Context!');
		});

		it('should handle React Suspense with Ripple await logic', async () => {
			vi.useFakeTimers();

			try {
				function sleep(ms: number) {
					return new Promise((resolve) => setTimeout(resolve, ms));
				}

				component AsyncRippleChild() {
					await sleep(1000);
					<div class="async-content">{'Loaded!'}</div>
				}

				function ReactChild() {
					return jsx(Ripple, { component: AsyncRippleChild });
				}

				component App() {
					<tsx:react>
						<Suspense fallback={<div className="loading">Loading...</div>}>
							<ReactChild />
						</Suspense>
					</tsx:react>
				}

				await act(async () => {
					render(App);
				});

				// Initially shows loading state
				const loading = container.querySelector('.loading');
				expect(loading).toBeTruthy();
				expect(loading.textContent).toBe('Loading...');
				expect(container.querySelector('.async-content')).toBeFalsy();

				// Advance timers to resolve the async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows loaded content
				const content = container.querySelector('.async-content');
				expect(content).toBeTruthy();
				expect(content.textContent).toBe('Loaded!');
				expect(container.querySelector('.loading')).toBeFalsy();
			} finally {
				vi.useRealTimers();
			}
		});

		it('should handle Ripple reactivity updates after Suspense resolves', async () => {
			vi.useFakeTimers();

			try {
				function sleep(ms: number) {
					return new Promise((resolve) => setTimeout(resolve, ms));
				}

				component AsyncRippleChild() {
					await sleep(1000);

					let count = track(0);

					<div>
						<div class="async-content">{'Loaded!'}</div>
						<div class="count">{@count}</div>
						<button onClick={() => @count++}>{'Increment'}</button>
					</div>
				}

				function ReactChild() {
					return jsx(Ripple, { component: AsyncRippleChild });
				}

				component App() {
					<tsx:react>
						<Suspense fallback={<div className="loading">Loading...</div>}>
							<ReactChild />
						</Suspense>
					</tsx:react>
				}

				await act(async () => {
					render(App);
				});

				// Initially shows loading state
				expect(container.querySelector('.loading')).toBeTruthy();
				expect(container.querySelector('.async-content')).toBeFalsy();

				// Advance timers to resolve the async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows loaded content with initial count
				expect(container.querySelector('.async-content')).toBeTruthy();
				expect(container.querySelector('.count').textContent).toBe('0');

				// Click button to increment count
				const button = container.querySelector('button');
				button.click();
				flushSync();

				// Count should be updated reactively
				expect(container.querySelector('.count').textContent).toBe('1');

				// Click again
				button.click();
				flushSync();

				expect(container.querySelector('.count').textContent).toBe('2');
			} finally {
				vi.useRealTimers();
			}
		});

		it('should handle tracked async triggering re-suspension on state change', async () => {
			vi.useFakeTimers();

			try {
				function sleep(ms: number) {
					return new Promise((resolve) => setTimeout(resolve, ms));
				}

				let setPage: (page: number) => void;

				component AsyncRippleChild({ page }: { page: number }) {
					// Using await track(() => ...) to create a reactive async operation
					// that re-suspends when the tracked dependency (page) changes
					await track(() => {
						page;
						return sleep(1000);
					});

					<div class="content">{`Page ${page} loaded`}</div>
				}

				function ReactChild(props: { page: number }) {
					return jsx(Ripple, {
						component: AsyncRippleChild,
						props: { page: props.page },
					});
				}

				component App() {
					let page = track(1);
					setPage = (p: number) => {
						@page = p;
					};

					<tsx:react>
						<Suspense fallback={<div className="loading">Loading...</div>}>
							<ReactChild page={@page} />
						</Suspense>
					</tsx:react>
				}

				await act(async () => {
					render(App);
				});

				// Initially shows loading state
				expect(container.querySelector('.loading')).toBeTruthy();
				expect(container.querySelector('.content')).toBeFalsy();

				// Advance timers to resolve the first async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows page 1 content
				expect(container.querySelector('.content')).toBeTruthy();
				expect(container.querySelector('.content').textContent).toBe('Page 1 loaded');
				expect(container.querySelector('.loading')).toBeFalsy();

				// Change page to trigger re-suspension via tracked dependency
				await act(async () => {
					setPage(2);
					flushSync();
				});

				// Should show loading again due to reactive async re-run
				expect(container.querySelector('.loading')).toBeTruthy();

				// Advance timers to resolve the second async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows page 2 content
				expect(container.querySelector('.content')).toBeTruthy();
				expect(container.querySelector('.content').textContent).toBe('Page 2 loaded');
				expect(container.querySelector('.loading')).toBeFalsy();
			} finally {
				vi.useRealTimers();
			}
		});

		it('should handle re-suspension via React key prop forcing remount', async () => {
			vi.useFakeTimers();

			try {
				function sleep(ms: number) {
					return new Promise((resolve) => setTimeout(resolve, ms));
				}

				let setPage: (page: number) => void;

				component AsyncRippleChild({ page }: { page: number }) {
					// Simple static await - no tracked dependencies
					await sleep(1000);

					<div class="content">{`Page ${page} loaded`}</div>
				}

				function ReactChild(props: { page: number }) {
					// Use key to force remount when page changes
					return jsx(Ripple, {
						key: props.page,
						component: AsyncRippleChild,
						props: { page: props.page },
					});
				}

				component App() {
					let page = track(1);
					setPage = (p: number) => {
						@page = p;
					};

					<tsx:react>
						<Suspense fallback={<div className="loading">Loading...</div>}>
							<ReactChild page={@page} />
						</Suspense>
					</tsx:react>
				}

				await act(async () => {
					render(App);
				});

				// Initially shows loading state
				expect(container.querySelector('.loading')).toBeTruthy();
				expect(container.querySelector('.content')).toBeFalsy();

				// Advance timers to resolve the first async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows page 1 content
				expect(container.querySelector('.content')).toBeTruthy();
				expect(container.querySelector('.content').textContent).toBe('Page 1 loaded');
				expect(container.querySelector('.loading')).toBeFalsy();

				// Change page to trigger re-suspension via key-based remount
				await act(async () => {
					setPage(2);
					flushSync();
				});

				// Should show loading again due to component remount
				expect(container.querySelector('.loading')).toBeTruthy();

				// Advance timers to resolve the second async operation
				await act(async () => {
					await vi.advanceTimersByTimeAsync(1000);
				});

				// Now shows page 2 content
				expect(container.querySelector('.content')).toBeTruthy();
				expect(container.querySelector('.content').textContent).toBe('Page 2 loaded');
				expect(container.querySelector('.loading')).toBeFalsy();
			} finally {
				vi.useRealTimers();
			}
		});
	});

	describe('Ripple in React app', () => {
		let container: null | Node;

		beforeEach(() => {
			container = document.createElement('div');
			document.body.appendChild(container);
		});

		afterEach(() => {
			document.body.removeChild(container!);
			container = null;
		});

		it('should render a basic React app', async () => {
			function App() {
				return jsx('div', { children: 'Hello from React App with RippleRoot' });
			}

			const root = createRoot(container!);

			await act(async () => {
				root.render(jsx(RippleRoot, { children: jsx(App, {}) }));
			});

			expect(container!.textContent).toBe('Hello from React App with RippleRoot');
		});

		it('should render a basic React app with RippleRoot', async () => {
			component RippleComponent() {
				<div>{'Hello from Ripple Component'}</div>
			}

			function App() {
				return jsxs('div', {
					children: [
						'Hello from React App with RippleRoot\n',
						jsx(Ripple, { component: RippleComponent }),
					],
				});
			}

			const root = createRoot(container!);

			await act(async () => {
				root.render(jsx(RippleRoot, { children: jsx(App, {}) }));
			});

			expect(container!.textContent).toBe(
				'Hello from React App with RippleRoot\nHello from Ripple Component',
			);
		});
	});
});
