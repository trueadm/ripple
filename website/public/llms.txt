# Ripple Framework - AI/LLM Documentation

## Overview

Ripple is a TypeScript UI framework that combines the best parts of React, Solid, and Svelte into one elegant package. Created by Dominic Gannaway ([@trueadm](https://github.com/trueadm)), Ripple is designed to be JS/TS-first with its own `.ripple` file extension that fully supports TypeScript.

**Key Characteristics:**
- **Performance**: Fine-grained rendering with industry-leading performance and memory usage
- **TypeScript-first**: Full TypeScript integration with type checking
- **JSX-like syntax**: Familiar templating with Ripple-specific enhancements
- **Reactive state**: Built-in reactivity with `track` and `@` reactive syntax
- **Component-based**: Clean, reusable components with props and children

## Installation & Setup

```bash
# Create new project from template
npx degit trueadm/ripple/templates/basic my-app
cd my-app
npm i && npm run dev

# Or install in existing project
npm install ripple
npm install --save-dev vite-plugin-ripple  # For Vite integration
```

## Core Syntax & Concepts

### Component Definition

Components are defined using the `component` keyword (not functions that return JSX):

```ripple
component Button(props: { text: string, onClick: () => void }) {
  <button onClick={props.onClick}>
    {props.text}
  </button>
}

// Usage
export component App() {
  <Button text="Click me" onClick={() => console.log("Clicked!")} />
}
```

### ⚠️ Critical: Text Content Must Be in Expressions

**IMPORTANT**: Unlike HTML or JSX, Ripple elements cannot contain raw text content. All text must be wrapped in JavaScript expressions using curly braces `{}`.

```ripple
// ❌ WRONG - Raw text not allowed
<div>Hello World</div>
<p>This will cause a compilation error</p>

// ✅ CORRECT - Text in expressions
<div>{"Hello World"}</div>
<p>{"This works correctly"}</p>

// ✅ CORRECT - Variables and expressions
<div>{greeting}</div>
<p>{`Dynamic content: ${value}`}</p>
```

This is because Ripple needs to distinguish between JavaScript code and literal strings within the template syntax. The parser cannot determine if `Hello` is meant to be a string literal or a JavaScript identifier without explicit expression syntax.

### ⚠️ Critical: Templates Only Inside Component Bodies

**IMPORTANT**: Ripple template syntax (JSX-like elements) can ONLY exist inside `component` function bodies. You cannot create JSX elements in regular functions, assign them to variables, or use them outside components.

```ripple
// ❌ WRONG - Templates outside component
const element = <div>{"Hello"}</div>;  // Compilation error

function regularFunction() {
  return <span>{"Not allowed"}</span>;  // Compilation error
}

const myTemplate = (
  <div>{"Cannot assign JSX"}</div>  // Compilation error
);

// ✅ CORRECT - Templates only inside components
component MyComponent() {
  // Template syntax is valid here
  <div>{"Hello World"}</div>

  // You can have JavaScript code mixed with templates
  const message = "Dynamic content";
  console.log("This JavaScript works");

  <p>{message}</p>
}

// ✅ CORRECT - Helper functions return data, not templates
function getMessage() {
  return "Hello from function";  // Return data, not JSX
}

component App() {
  <div>{getMessage()}</div>  // Use function result in template
}
```

This design enforces clear separation between component templates and regular JavaScript logic, making code more predictable and easier to analyze.

### Template Lexical Scoping

**Unique Feature**: Ripple templates act as lexical scopes, allowing you to declare variables, call functions, and execute JavaScript statements directly within JSX elements - similar to block statements in regular JavaScript.

```ripple
component TemplateScope() {
  <div>
    // Variable declarations inside templates
    const message = "Hello from template scope";
    let count = 42;

    // Function calls and expressions
    console.log("This runs during render");

    // Conditional logic
    const isEven = count % 2 === 0;

    <h1>{message}</h1>
    <p>{"Count is: "}{count}</p>

    if (isEven) {
      <span>{"Count is even"}</span>
    }

    // Nested scopes work too
    <section>
      const sectionData = "Nested scope variable";
      <p>{sectionData}</p>
    </section>

    // You can even put debugger statements
    debugger;
  </div>
}
```

**Key Benefits:**
- **Inline Logic**: Execute JavaScript directly where you need it in the template
- **Local Variables**: Declare variables scoped to specific parts of your template
- **Debugging**: Place `console.log()` or `debugger` statements anywhere in templates
- **Dynamic Computation**: Calculate values inline without helper functions

**Scope Rules:**
- Variables declared in templates are scoped to that template block
- Nested elements create nested scopes
- Variables from outer scopes are accessible in inner scopes
- Template variables don't leak to the component function scope

### Reactive Variables

You use `track` to create a single tracked value. The `track` function creates a `Tracked<V>` object that is not accessible from the outside, and instead you must use `@` to read or write to the tracked value:

```ripple
import { track } from 'ripple';

export component Counter() {
  let count = track(0);
  let double = track(() => @count * 2);  // Derived reactive value

  <div>
    <p>{"Count: "}{@count}</p>
    <p>{"Double: "}{@double}</p>
    <button onClick={() => @count++}>{"Increment"}</button>
  </div>
}
```

Objects can also contain tracked values with `@` to access the reactive object property:
```ripple
let counter = { current: track(0) };
counter.@current++;  // Triggers reactivity
```

Tracked derived values are also `Tracked<V>` objects, except you pass a function to `track` rather than a value:

```ripple
let count = track(0);
let double = track(() => @count * 2);
let quadruple = track(() => @double * 2);

console.log(@quadruple);
```

If you want to use a tracked value inside a reactive context, such as an effect but you don't want that value to be a tracked dependency, you can use `untrack`:

```ripple
let count = track(0);
let double = track(() => @count * 2);
let quadruple = track(() => @double * 2);

effect(() => {
  // This effect will never fire again, as we've untracked the only dependency it has
  console.log(untrack(() => @quadruple));
})
```

> Note: you cannot create `Tracked` objects in module/global scope, they have to be created on access from an active component context.

#### track with get / set

The optional get and set parameters of the `track` function let you customize how a tracked value is read or written, similar to property accessors but expressed as pure functions. The get function receives the current stored value and its return value is exposed when the tracked value is accessed / unboxed with `@`. The set function should return the value that will actually be stored and receives two parameters: the first is the one being assigned and the second with the previous value.  The get and set functions may be useful for tasks such as logging, validating, or transforming values before they are exposed or stored.

```ripple
import { track } from 'ripple';

export component App() {
  let count = track(0,
    (current) => {
      console.log(current);
      return current;
    },
    (next, prev) => {
      console.log(prev);
      if (typeof next === 'string') {
        next = Number(next);
      }

      return next;
    }
  );
}

> Note: If no value is returned from either `get` or `set`, `undefined` is either exposed (for get) or stored (for set). Also, if only supplying the `set`, the `get` parameter must be set to `undefined`.

#### trackSplit Function

The `trackSplit` "splits" a plain object — such as component props — into specified tracked variables and an extra `rest` property containing the remaining unspecified object properties.

```jsx
const [children, count, rest] = trackSplit(props, ['children', 'count']);
```

When working with component props, destructuring is often useful — both for direct use as variables and for collecting remaining properties into a `rest` object (which can be named arbitrarily). If destructuring happens in the component argument, e.g. `component Child({ children, value, ...rest })`, Ripple automatically links variable access to the original props — for example, `value` is compiled to `props.value`, preserving reactivity. However, destructuring inside the component body, e.g. `const { children, value, ...rest } = props`, does not preserve reactivity due to various edge cases. To ensure destructured variables remain reactive in this case, use the `trackSplit` function.

A full example utilizing various Ripple constructs demonstrates the `split` option usage:

```jsx
import { track, trackSplit } from 'ripple';
import type { PropsWithChildren, Tracked } from 'ripple';

component Child(props: PropsWithChildren<{ count: Tracked<number> }>) {
  const [children, count, className, rest] = trackSplit(props, ['children', 'count', 'class']);

  <button class={@className} {...@rest}><@children /></button>
  <pre>{`Count is: ${@count}`}</pre>
  <button onClick={() => @count++}>{'Increment Count'}</button>
}

export component App() {
  let count = track(0);
  let className = track('shadow');
  let name = track('Click Me');

  function buttonRef(el) {
    console.log('ref called with', el);
    return () => {
      console.log('cleanup ref for', el);
    };
  }

  <Child
    class={@className}
    onClick={() => { @name === 'Click Me' ? @name = 'Clicked' : @name = 'Click Me'; @className = ''}}
    count:={() => @count, (v) => {console.log('inside setter'); @count++}}
    {ref buttonRef}
  >{@name}</Child>;
}
```

With the regular destructuring, such as the one below, the `count` and `class` properties would lose their reactivity:

```jsx
// ❌ WRONG Reactivity would be lost
let { children, count, class: className, ...rest } = props;
```

> Note: Make sure the resulting `rest`, if it's going to be spread onto a dom element, does not contain `Tracked` values.  Otherwise, you'd be spreading not the actual values but the boxed ones, which are objects that will appear as `[Object object]` on the dom element.

### Transporting Reactivity

**Critical Concept**: Ripple doesn't constrain reactivity to components only. `Tracked<V>` objects can simply be passed by reference between boundaries to improve expressivity and co-location.

#### Basic Transport Pattern
```ripple
import { effect, track } from 'ripple';

function createDouble(count) {
  const double = track(() => @count * 2);

  effect(() => {
    console.log('Count:', @count)
  });

  return double;
}

export component App() {
  let count = track(0);

  const double = createDouble(count);

  <div>{'Double: ' + @double}</div>
  <button onClick={() => { @count++; }}>{'Increment'}</button>
}
```

#### Dynamic Component Transport Pattern

Ripple has built-in support for dynamic components, a way to render different components based on reactive state. Instead of hardcoding which component to show, you can store a component in a `Tracked` via `track()`, and update it at runtime. When the tracked value changes, Ripple automatically unmounts the previous component and mounts the new one. Dynamic components are written with the `<@Component />` tag, where the @ both unwraps the tracked reference and tells the compiler that the component is dynamic. This makes it straightforward to pass components as props or swap them directly within a component, enabling flexible, state-driven UIs with minimal boilerplate.

```ripple
export component App() {
  let swapMe = track(() => Child1);

  <Child {swapMe} />

  <button onClick={() => @swapMe = @swapMe === Child1 ? Child2 : Child1}>{'Swap Component'}</button>
}

component Child({ swapMe }: {swapMe: Tracked<Component>}) {
  <@swapMe />
}

component Child1(props) {
  <pre>{'I am child 1'}</pre>
}

component Child2(props) {
  <pre>{'I am child 2'}</pre>
}
```

**Transport Rules:**
- Reactive state must be connected to a component
- Cannot be global or created at module/global scope
- Use arrays `[ trackedVar ]` or objects `{ trackedVar }` to transport reactivity
- Functions can accept and return reactive state using these patterns
- This enables composable reactive logic outside of component boundaries

### Control Flow

#### If Statements
```ripple
component Conditional({ isVisible }) {
  <div>
    if (isVisible) {
      <span>{"Visible content"}</span>
    } else {
      <span>{"Hidden state"}</span>
    }
  </div>
}
```

#### For Loops
```ripple
component List({ items }) {
  <ul>
    for (const item of items) {
      <li>{item.text}</li>
    }
  </ul>
}
```

#### For Loops with index
```ripple
component ListView({ title, items }) {
  <h2>{title}</h2>
  <ul>
    for (const item of items; index i) {
      <li>{item.text}{' at index '}{i}</li>
    }
  </ul>
}
```

#### Try-Catch (Error Boundaries)
```ripple
component ErrorBoundary() {
  <div>
    try {
      <ComponentThatMightFail />
    } catch (e) {
      <div>{"Error: "}{e.message}</div>
    }
  </div>
}
```

### Children Components

Use `children` prop for component composition:

```ripple
import type { Component } from 'ripple';

component Card(props: { children: Component }) {
  <div class="card">
    <children />
  </div>
}

// Usage
<Card>
  <p>{"Card content here"}</p>
</Card>
```

### Events

#### Attribute Event Handling

Events follow React-style naming (`onClick`, `onPointerMove`, etc.):

```ripple
component EventExample() {
  let message = track("");

  <div>
    <button onClick={() => @message = "Clicked!"}>{"Click me"}</button>
    <input onInput={(e) => @message = e.target.value} />
    <p>{@message}</p>
  </div>
}
```

For capture phase events, add `Capture` suffix:
- `onClickCapture`
- `onPointerDownCapture`

#### Direct Event Handling

Use function `on` to attach events to window, document or any other element instead of addEventListener.
This method guarantees the proper execution order with respect to attribute-based handlers such as `onClick`, and similarly optimized through event delegation for those events that support it.

```ripple
import { effect, on } from 'ripple';

export component App() {
  effect(() => {
    // on component mount
    const removeListener = on(window, 'resize', () => {
      console.log('Window resized!');
    });

    // return the removeListener when the component unmounts
    return removeListener;
  });
}
```

### Styling

Components support scoped CSS with `<style>` elements:

```ripple
component StyledComponent() {
  <div class="container">
    <h1>{"Styled Content"}</h1>
  </div>

  <style>
    .container {
      background: blue;
      padding: 1rem;
    }
    h1 {
      color: white;
      font-size: 2rem;
    }
  </style>
}
```

#### Dynamic Classes

In Ripple, the `class` attribute can accept more than just a string — it also supports objects and arrays. Truthy values are included as class names, while falsy values are omitted. This behavior is powered by the `clsx` library.

Examples:

```ripple
let includeBaz = track(true);
<div class={{ foo: true, bar: false, baz: @includeBaz }}></div>
// becomes: class="foo baz"

<div class={['foo', {baz: false}, 0 && 'bar', [true && 'bat'] ]}></div>
// becomes: class="foo bat"

let count = track(3);
<div class={['foo', {bar: @count > 2}, @count > 3 && 'bat']}></div>
// becomes: class="foo bar"
```

### DOM References (Refs)

Use `{ref fn}` syntax to capture DOM element references:

```ripple
export component App() {
  let div = track();

  const divRef = (node) => {
    @div = node;
    console.log("mounted", node);

    return () => {
      @div = undefined;
      console.log("unmounted", node);
    };
  };

  <div {ref divRef}>{"Hello world"}</div>
}
```

Inline refs:
```ripple
<div {ref (node) => console.log(node)}>{"Content"}</div>
```

## Built-in APIs

### Core Functions
```typescript
import {
  mount,           // Mount component to DOM
  track,           // Create reactive state
  untrack,         // Prevent reactivity tracking
  flushSync,       // Synchronous state updates
  effect,          // Side effects
  createContext    // Context API
} from 'ripple';
```

### Mount API
```typescript
mount(App, {
  props: { title: 'Hello world!' },
  target: document.getElementById('root')
});
```

### Effects
```ripple
import { effect, track } from 'ripple';

export component App() {
  let count = track(0);

  effect(() => {
    console.log("Count changed:", @count);
  });

  <button onClick={() => @count++}>{"Increment"}</button>
}
```

### Context
```ripple
import { createContext } from 'ripple';

const ThemeContext = createContext('light');

component Child() {
  const theme = ThemeContext.get();
  <div class={theme}>{"Themed content"}</div>
}

component Parent() {
  ThemeContext.set('dark');
  <Child />
}
```

### Reactive Collections

#### Simple Reactive Arrays

Just like objects, you can use the `Tracked<V>` objects in any standard JavaScript object, like arrays:

```ripple
let first = track(0);
let second = track(0);
const arr = [first, second];

const total = track(() => arr.reduce((a, b) => a + @b, 0));

console.log(@total);
```

Like shown in the above example, you can compose normal arrays with reactivity and pass them through props or boundaries.

However, if you need the entire array to be fully reactive, including when new elements get added, you should use the reactive array that Ripple provides.

#### TrackedArray

`TrackedArray` class from Ripple extends the standard JS `Array` class, and supports all of its methods and properties. Import it from the `'ripple'` namespace or use the provided syntactic sugar for a quick creation via the bracketed notation. All elements existing or new of the `TrackedArray` are reactive and respond to the various array operations such as push, pop, shift, unshift, etc. Even if you reference a non-existent element, once it added, the original reference will react to the change. You do NOT need to use the unboxing `@` with the elements of the array.

```ripple
import { TrackedArray } from 'ripple';

// using syntactic sugar `#`
const arr = #[1, 2, 3];

// using the new constructor
const arr = new TrackedArray(1, 2, 3);

// using static from method
const arr = TrackedArray.from([1, 2, 3]);

// using static of method
const arr = TrackedArray.of(1, 2, 3);
```

Usage Example:

```ripple
export component App() {
  const items = new #[1, 2, 3];

  <div>
    <p>{"Length: "}{items.length}</p>  // Reactive length
    for (const item of items) {
      <div>{item}</div>
    }
    <button onClick={() => items.push(items.length + 1)}>{"Add"}</button>
  </div>
}
```

#### TrackedObject

`TrackedObject` class extends the standard JS `Object` class, and supports all of its methods and properties. Import it from the `'ripple'` namespace or use the provided syntactic sugar for a quick creation via the curly brace notation.  `TrackedObject` fully supports shallow reactivity and any property on the root level is reactive.  You can even reference non-existent properties and once added the original reference reacts to the change. You do NOT need to use the unboxing `@` with the properties of the `TrackedObject`.

```ripple
import { TrackedObject } from 'ripple';

// using syntactic sugar `#`
const arr = #{a: 1, b: 2, c: 3};

// using the new constructor
const arr = new TrackedObject({a: 1, b: 2, c: 3});
```

Usage Example:

```ripple
export component App() {
  const obj = #{a: 0}

  obj.a = 0;

  <pre>{'obj.a is: '}{obj.a}</pre>
  <pre>{'obj.b is: '}{obj.b}</pre>
  <button onClick={() => { obj.a++; obj.b = obj.b ?? 5; obj.b++; }}>{'Increment'}</button>
}
```

#### TrackedSet
```ripple
import { TrackedSet } from 'ripple';

component SetExample() {
  const mySet = new TrackedSet([1, 2, 3]);

  <div>
    <p>{"Size: "}{mySet.size}</p>  // Reactive size
    <p>{"Has 2: "}{mySet.has(2)}</p>
    <button onClick={() => mySet.add(4)}>{"Add 4"}</button>
  </div>
}
```

## Advanced Features

### Untracking Reactivity
```ripple
import { untrack, track, effect } from 'ripple';

let count = track(0);
let double = track(() => @count * 2);
let quadruple = track(() => @double * 2);

effect(() => {
  // This effect will never fire again, as we've untracked the only dependency it has
  console.log(untrack(() => @quadruple));
})
```

### Prop Shortcuts
```ripple
// Object spread
<div {...properties}>{"Content"}</div>

// Shorthand props (when variable name matches prop name)
<div {onClick} {className}>{"Content"}</div>

// Equivalent to:
<div onClick={onClick} className={className}>{"Content"}</div>
```

### Raw HTML

All text nodes are escaped by default in Ripple. To render trusted raw HTML strings, use
the `{html}` directive.

```ripple
export component App() {
	let source = `
<h1>My Blog Post</h1>
<p>Hi! I like JS and Ripple.</p>
`

	<article>
		{html source}
	</article>
}
```

## TypeScript Integration

### Component Types
```typescript
import type { Component } from 'ripple';

interface Props {
  value: string;
  label: string;
  children?: Component;
}

component MyComponent(props: Props) {
  // Component implementation
}
```

### Context Types
```typescript
type Theme = 'light' | 'dark';
const ThemeContext = createContext<Theme>('light');
```

## File Structure

```
src/
  App.ripple          # Main app component
  components/
    Button.ripple     # Reusable components
    Card.ripple
  index.ts           # Entry point with mount()
```

## Development Tools

### VSCode Extension
- **Name**: "Ripple for VS Code"
- **ID**: `ripplejs.ripple-vscode-plugin`
- **Features**: Syntax highlighting, diagnostics, TypeScript integration, IntelliSense

### Vite Plugin
```typescript
// vite.config.js
import { defineConfig } from 'vite';
import ripple from 'vite-plugin-ripple';

export default defineConfig({
  plugins: [ripple()]
});
```

### Prettier Plugin
```javascript
// .prettierrc
{
  "plugins": ["prettier-plugin-ripple"]
}
```

## Key Differences from Other Frameworks

### vs React
- No JSX functions/returns - components use statement-based templates
- Built-in reactivity with `track` and `@` syntax instead of useState/useEffect
- Scoped CSS without CSS-in-JS libraries
- No virtual DOM - fine-grained reactivity

### vs Svelte
- TypeScript-first approach
- JSX-like syntax instead of HTML templates
- `.ripple` extension instead of `.svelte`
- Similar reactivity concepts but different syntax

### vs Solid
- Component definition with `component` keyword
- Built-in collections (TrackedArray, TrackedSet)
- Different templating approach within component bodies

## Best Practices

1. **Reactivity**: Use `track()` to create reactive variables and `@` to access them
2. **Strings**: Wrap string literals in `{"string"}` within templates
3. **Effects**: Use `effect()` for side effects, not direct reactive variable access
4. **Components**: Keep components focused and use TypeScript interfaces for props
5. **Styling**: Use scoped `<style>` elements for component-specific styles
6. **Collections**: Use TrackedArray/TrackedSet for reactive collections instead of regular arrays/sets

## Current Limitations

- **SSR**: Currently SPA-only (Server-Side Rendering not yet implemented)
- **Types**: Some areas of the codebase have limited TypeScript coverage
- **Ecosystem**: Early stage - limited third-party library ecosystem
- **Production Ready**: Currently in early development/alpha stage

## Resources

- **Website**: https://ripplejs.com
- **GitHub**: https://github.com/trueadm/ripple
- **VSCode Extension**: https://marketplace.visualstudio.com/items?itemName=ripplejs.ripple-vscode-plugin

---

This documentation is optimized for AI/LLM understanding of the Ripple framework. For the most up-to-date information, visit https://ripplejs.com or the GitHub repository.
